from __future__ import annotations
from datetime import datetime, timedelta, date
from homeassistant.components.sensor import SensorEntity
from homeassistant.core import HomeAssistant
from homeassistant.config_entries import ConfigEntry
from homeassistant.helpers.entity_platform import AddEntitiesCallback

# Constants (make sure these match your config_flow.py)
CONF_NAME = "name"
CONF_ICON = "icon"
CONF_RECURRENCE_TYPE = "recurrence_type"
CONF_INTERVAL = "interval"
CONF_DAY_OF_MONTH = "day_of_month"
CONF_MONTH = "month"
CONF_START_DATE = "start_date"
CONF_PERSON_ENTITY = "person_entity"


async def async_setup_entry(
    hass: HomeAssistant,
    entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """Set up Chore Tracker sensor from a config entry."""
    data = entry.data
    entity = ChoreTrackerSensorEntity(
        unique_id=entry.entry_id,
        name=data.get(CONF_NAME),
        recurrence_type=data.get(CONF_RECURRENCE_TYPE),
        interval=data.get(CONF_INTERVAL, 1),
        day_of_month=data.get(CONF_DAY_OF_MONTH),
        month=data.get(CONF_MONTH),
        start_date=datetime.fromisoformat(data.get(CONF_START_DATE)).date(),
        icon=data.get(CONF_ICON),
        person_entity=data.get(CONF_PERSON_ENTITY),
    )
    async_add_entities([entity])


class ChoreTrackerSensorEntity(SensorEntity):
    """Sensor entity representing a chore recurrence."""

    def __init__(
        self,
        unique_id: str,
        name: str,
        recurrence_type: str,
        interval: int,
        day_of_month: int | None,
        month: int | None,
        start_date: date,
        icon: str | None,
        person_entity: str | None,
    ):
        self._unique_id = unique_id
        self._name = name
        self._recurrence_type = recurrence_type
        self._interval = int(interval) if interval else 1
        self._day_of_month = int(day_of_month) if day_of_month else None
        self._month = int(month) if month else None
        self._start_date = start_date
        self._icon = icon
        self._person_entity = person_entity

        # Calculate first due date
        self._due_date: datetime | None = self._calculate_next_due(self._start_date)

    @property
    def unique_id(self) -> str:
        return self._unique_id

    @property
    def name(self) -> str:
        return self._name

    @property
    def icon(self) -> str | None:
        return self._icon

    @property
    def state(self) -> str | None:
        """Return the next due date as the sensor state."""
        if self._due_date:
            return self._due_date.date().isoformat()
        return None

    @property
    def extra_state_attributes(self) -> dict:
        """Expose recurrence details as attributes."""
        attrs: dict = {
            "recurrence_type": self._recurrence_type,
            "interval": self._interval,
            "start_date": self._start_date.isoformat(),
        }
        if self._day_of_month:
            attrs["day_of_month"] = self._day_of_month
        if self._month:
            attrs["month"] = self._month
        if self._due_date:
            attrs["next_due"] = self._due_date.isoformat()
        if self._person_entity:
            attrs["assigned_to"] = self._person_entity
        return attrs

    def _calculate_next_due(self, start_date: date) -> datetime | None:
        """Calculate the next due date based on recurrence type and interval."""
        recurrence_type = self._recurrence_type
        interval = int(self._interval) if self._interval else 1

        year = int(start_date.year)
        month = int(start_date.month)
        day = int(start_date.day)

        if recurrence_type == "daily":
            return datetime(year, month, day) + timedelta(days=interval)

        elif recurrence_type == "weekly":
            return datetime(year, month, day) + timedelta(weeks=interval)

        elif recurrence_type == "monthly":
            new_month = month + interval
            new_year = year
            while new_month > 12:
                new_month -= 12
                new_year += 1

            max_day = [
                31,
                29 if new_year % 4 == 0 else 28,
                31,
                30,
                31,
                30,
                31,
                31,
                30,
                31,
                30,
                31,
            ][new_month - 1]
            new_day = min(int(self._day_of_month or day), max_day)

            return datetime(new_year, new_month, new_day)

        elif recurrence_type == "yearly":
            new_year = year + interval
            new_month = int(self._month or month)
            new_day = int(self._day_of_month or day)

            max_day = [
                31,
                29 if new_year % 4 == 0 else 28,
                31,
                30,
                31,
                30,
                31,
                31,
                30,
                31,
                30,
                31,
            ][new_month - 1]
            new_day = min(new_day, max_day)

            return datetime(new_year, new_month, new_day)

        return None
